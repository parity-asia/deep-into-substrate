# Substrate交易和交易池

本篇，我们一起来探讨在Substrate中，交易和交易池的原理和实现。

## Extrinsic的定义

在Substrate中，把我们通常所谓的“交易”的概念扩展了一些，凡是所有从“链外”来的有意改变链上数据的请求/数据都叫作Extrinsic ，它是传统的交易（Transaction）的概念上的扩展。但是在术语的使用上来说，Substrate官方文档及其社区，又常常把这两个词混用，一般不会有什么问题。后文我们通用Transaction或交易一词。

  ### 3种Extrinsic

Substrate把Extrinsic分为3种：签名交易、不签名交易和内在交易。

- 签名交易：Signed Transaction
- 不签名交易：Unsigned Transaction
- 内在交易：Inherent Transaction

签名交易指的是发送到链上的交易，需要通过一个账户进行签名。（我们回顾一下所谓签名的意思是：使用一个账户的私钥对一个数据片进行加密，然后把这个加密后的数据片单独或随着其它数据一起上传到某个地方，在那个地方之前已经有这个账户的公钥了，于是可以使用这那个公钥对这片数据进行解密。只要能正常解密，就能证明这个请求就是这个账户发送过来的，绝无伪造的可能）。

一般我们的交易都会使用签名交易类型。一方面是因为我们需要知道一个交易是从哪个确切的账户发出的，防止做假；另一方面也是因为要更新链上数据，一般是需要收费的（链上的执行和存储都比较昂贵，收费是一种防止攻击的方式）。如果不知道是哪个账户传上来的，就不知道从哪个账户里面扣费了。对，扣费。既然要扣费，就说明那个账户在链上需要预先有余额。余额如果不够，又是一种需要面对的情况。所以这后面还有一整套的逻辑。Substrate把这些底层的机制都给我们准备好了。

不签名交易是指，发交易的时候，不使用某个账户对其签名。是与签名交易相对的一种交易。这种交易在其它区块链上一般看不到，或不会开放给用户使用。因为交易不签名，是一件很危险的事情。既不知道是谁发的，也无法向某个账户收费，就失去了一种防止垃圾攻击的手段。

那么，为什么Substrate链愿意接收这样一种交易呢？或者说，什么情况下，会用到这样一种类型的交易呢？

这种交易是给参与链网络共识的验证者（Validator）使用的，效率会比较高。比如，验证者要给其它节点提供“我在线”这种心跳信息，这种信息对于维护网络健康而言是必要的，但是这种信息就没必要收费了，验证者本身对应的账户上也可能没余额。另外一个例子是，一个验证者的Offchain Worker (OCW)里面，可以向链上发交易。因为这个交易也来自验证者内部，所以选择用不签名交易是可以防止被收费的。

但是，不签名交易毕竟不安全，所以Substrate规定了，对于这种交易，必须显式地在Runtime里面，手动实现对每个这种交易的验证逻辑。也就是说，对这类交易，由开发者自己来定义验证的逻辑。

内在交易，是一种特殊的不签名交易。这种交易，由且只能由当前出块人（验证人集中的一个）向块中直接插入，在创建交易的时候，不会向网络广播，因此其它验证人不会收到这类交易。这种交易作为一批交易中的一个，被放在块中。其它验证人通过网络收到块后，再判断这个交易是否合法。最典型（好像目前唯一）的场景是出块人向块中插入出块时的时间戳。



 ### 交易的作用
  
## Substrate中交易的格式

## 客户端通过rpc发交易的验证
    ### subxt
    ### polkadotjs

## 交易池
    ### substrate中的交易池实现
    ### 校验规则
    ### Runtime参与的部分
    ### SignedExtensions

## 交易的广播

## 交易入块
    ### 块头的结构
    ### 交易在块中的组织
    ### tx merkle root
    ### 如何验证一个交易在块中
    ### 出块节点交易的执行，执行后的状态
    ### 块打包并广播

## 块导入时的工作
    ### 块导入时的校验
    ### 块导入时交易的执行
    ### 全局状态更新
    
## 交易的生命期总结

## Runtime中有关交易的几个Pallet
    ### System
    ### im
    ### transaction-payment
    ### ...

## 其它一些专题问题
    ### 如何创建不在网络上传播的交易
    ### OCW如何创建交易
